---
output: rmarkdown::github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="##", fig.retina=2, fig.path = "README_figs/README-")
```

Roadmap:

predict electricity load* with and without wind power using linear and non-linear methods (neural network, svm?),

report results/conclusions

-data exploration,data visualizations (make heatmap)

*predict 24 hour load using past history of demands and identify how wind energy affects energy forecasting
# Electricity Load Prediction in Texas



## Introduction

How do electric companies know how much power they have to generate? 


But why is it important to predict hourly demand for electricity at least a day in advance? You need to know much generators needs to be on to meet the expected demand and turning on a generator requires time.



## Libraries/packages we will be using
```{r libraries, message=FALSE, warning=FALSE}
new_cran_packages <- c("ggplot2", "caret","stringr")
existing_packages <- installed.packages()[,"Package"]
missing_packages <- new_cran_packages[!(new_cran_packages %in% existing_packages)]
if(length(missing_packages)){
    install.packages(missing_packages)
}

library(ggplot2)
library(stringr)
library(caret)
```


## Load the ERCOT 2018 data
```{r dataset, echo=FALSE}
dfDemand = read.csv("ERCOT_2018_Hourly_Wind_Output.csv")
demands = dfDemand$ERCOT.Load..MW
numberOfDays = length(demands)/24
```


Let's see how does load vary over the year in Texas.
```{r electricity graph, echo=FALSE}
days = vector(length = numberOfDays * 24)
for (hour in seq_len(numberOfDays * 24)) {
  days[hour] = hour / 24 
}

ggplot(dfDemand, aes(x = days, y = demands)) + geom_line(color = "dodgerblue") + 
  labs(title = "Texas Electricity Demands in 2018", x = "Days in 2018", y = "Net Demand of Texas (in MW)") 
```


## Wind data

```{r wind output graph, echo=FALSE}
dfDemand$Windless_Load = dfDemand$ERCOT.Load..MW - dfDemand$Total.Wind.Output..MW
windDemand = dfDemand$Windless_Load
windOutput = dfDemand$Total.Wind.Output..MW

ggplot(dfDemand, aes(x = days, y = windOutput)) + geom_line(color = "orange") + 
  labs(title = "Texas Wind Power Output in 2018", x = "Days in 2018", y = "MegaWatts")
```

Wind Power looks very sporadic while electricity demands seems to have a trend.

```{r January HeatMap, echo=FALSE}
monthOfJan = dfDemand[grep("Jan", dfDemand$Date), ]
monthOfJan$Day = str_split_fixed(monthOfJan$誰..time.date.stamp, " ", 2)[,1]
monthOfJan$Hour = str_split_fixed(monthOfJan$誰..time.date.stamp, " ", 2)[,2]
monthOfJan$Day = as.Date(monthOfJan$Day, "%m/%d/%Y")
monthOfJan$Hour = as.numeric(format(strptime(monthOfJan$Hour,"%H:%M:%S"),'%H'))

#monthOfJan = monthOfJan %>% 
 # mutate(weekday = weekdays(Day)) %>%
  #mutate(weekday = factor(weekday, levels = c("Sunday", "Monday", "Tuesday", "Wednesday",
   #                                           "Thursday", "Friday", "Saturday")))

theme_heatmap = theme_light() +
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        plot.title = element_text(face = "bold", size = 11, hjust = 0.5),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 10),
        axis.text.x = element_text(size = 10, angle = 90, hjust = 1),
        axis.text.y = element_text(size = 8))

ggJan = ggplot(monthOfJan, mapping = aes(x = Date, y = Hour, fill = ERCOT.Load..MW)) +
  geom_tile(colour = "white") + 
  scale_fill_gradient(low = "#f4fff6", high="#ed420e") +
  scale_y_reverse(breaks=c(23:0), labels=c(23:0), expand = c(0,0)) +
  scale_x_discrete(expand = c(0,0), position = "top") +
  labs(title = "Electricity Demand in January 2018", y = "Hour of Day", fill = "Load (in MW)") + 
  theme_heatmap 

print(ggJan)

```
```{r July HeatMap, echo=FALSE}
monthOfJuly <- dfDemand[grep("Jul", dfDemand$Date), ]
monthOfJuly$Day = str_split_fixed(monthOfJuly$誰..time.date.stamp, " ", 2)[,1]
monthOfJuly$Hour = str_split_fixed(monthOfJuly$誰..time.date.stamp, " ", 2)[,2]
monthOfJuly$Day = as.Date(monthOfJuly$Day, "%m/%d/%Y")
monthOfJuly$Hour = as.numeric(format(strptime(monthOfJuly$Hour,"%H:%M:%S"),'%H'))

ggJuly = ggplot(monthOfJuly, mapping = aes(x = Date, y = Hour, fill = ERCOT.Load..MW)) +
  geom_tile(colour = "white") + 
  scale_fill_gradient(low = "#f4fff6", high="#ed420e") +
  scale_y_reverse(breaks=c(23:0), labels=c(23:0), expand = c(0,0)) +
  scale_x_discrete(expand = c(0,0), position = "top") +
  labs(title = "Electricity Demand in July 2018", y = "Hour of Day", fill = "Load (in MW)") +
  theme_heatmap 

print(ggJuly)
```



## Demand Prediction Strategy and Data Aggregation

For our independent variables we will use past week, past 2 days, past 1 day to predict the electiricty demand of tomorrow. i.e days to train on -7, -2, -1


```{r organize data}
daysToTrainOn = c(-7,-2,-1)
rangeOfDays = seq(-min(daysToTrainOn), numberOfDays - 1, by = 1)

Y = NULL
for (day in rangeOfDays) {
  Y = rbind(Y, dfDemand$ERCOT.Load..MW[(day * 24): ((day + 1) * 24 - 1)])
}

X = NULL
for (day in rangeOfDays) {
  X_temp = cbind(t(dfDemand$ERCOT.Load..MW[(((day - 7)*24 +1)):((day - 7 + 1)*24)]),
            t(dfDemand$ERCOT.Load..MW[(((day - 2)*24) +1):((day - 2 + 1)*24)]),
            t(dfDemand$ERCOT.Load..MW[(((day - 1)*24) +1):((day - 1 + 1)*24)]))
  X = rbind(X, X_temp)
}
dim(X)
dim(Y)
```

## Windless
```{r}
daysToTrainOn = c(-7,-2,-1)
rangeOfDays = seq(-min(daysToTrainOn), numberOfDays - 1, by = 1)

Y = NULL
for (day in rangeOfDays) {
  Y = rbind(Y, dfDemand$Windless_Load[(day * 24): ((day + 1) * 24 - 1)])
}

X = NULL
for (day in rangeOfDays) {
  X_temp = cbind(t(dfDemand$Windless_Load[(((day - 7)*24 +1)):((day - 7 + 1)*24)]),
            t(dfDemand$Windless_Load[(((day - 2)*24) +1):((day - 2 + 1)*24)]),
            t(dfDemand$Windless_Load[(((day - 1)*24) +1):((day - 1 + 1)*24)]))
  X = rbind(X, X_temp)
}
dim(X)
dim(Y)
```

After Organzing the data we will start making our train and test data.
*talk about normalizing the data

```{r}
test_inds = createDataPartition(y = 1:nrow(Y), p = 0.2, list = F)
X_test = X[test_inds, ]; Y_test = Y[test_inds]
X_train = X[-test_inds, ]; Y_train = Y[-test_inds]

X_train_scaled = scale(X_train)
X_test_scaled = scale(X_test, center=attr(X_train_scaled, "scaled:center"), 
                              scale=attr(X_train_scaled, "scaled:scale"))

mean(X_train_scaled); mean(X_test_scaled)
sd(X_train_scaled); sd(X_test_scaled)
```

## Prediction

###try neural network
```{r}
#lin <- lm(Y_train ~ X_train_scaled)
#summary(lin)
```





